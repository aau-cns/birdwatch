import tkinter
from datetime import datetime
from typing import List

import customtkinter as ctk
import yaml

import Widgets.ThemedCtkWidgets as tcw
from FileManager import FileManager as fm
from IconManager import IconManager
from LogManager import LogManager
from PopUpWindows import ConfirmationWindow, MessageWindow
from Settings import Settings
from ShellCommands import ShellCommands as sh
from Widgets.EntryWithLabel import EntryWithLabel
from Widgets.FileDialog import FileDialog
from Widgets.SafeButton import SafeButton


class RecordTopicsTabView(tcw.CTkFrame):
    last_recording: str = None

    def __init__(self, master):
        super().__init__(master)

        self.configure(fg_color="transparent")
        self.columnconfigure((0, 1, 2), weight=1)
        self.rowconfigure(0, weight=1)
        self.ros_version = sh.execute('echo $ROS_VERSION')

        # Add topics
        self.topics_frame = TopicsFrame(self)
        self.topics_frame.grid(
            row=0, column=0, columnspan=3, pady=(0, 10), sticky="new"
        )

        # Add backup button
        self.view_recordings_btn = tcw.CTkButton(
            self,
            text="View recordings",
            command=self.view_recordings,
            tooltip_text="Visualize the recordings stored in\n"
            + f"'{Settings.current_device.files.recordings.path}'\n"
            + "in the remote device to a specified location",
        )
        self.view_recordings_btn.grid(
            row=1, column=0, padx=(0, 10), pady=(0, 10), sticky="sw"
        )

        # Add move map button
        self.move_map_btn = tcw.CTkButton(
            self,
            text="Move map",
            command=self.move_map,
            tooltip_text=(
                "Move the map generated by RTABMAP to\n"
                + Settings.current_device.files.recordings.path,
                "Stop recording before moving the map",
            ),
        )
        self.move_map_btn.grid(row=2, column=0, padx=(0, 10), sticky="sw")

        # Add stop recording button
        self.stop_btn = SafeButton(
            self,
            text="Stop recording",
            slider_width=20,
            command=self.stop_recording,
            slider_tooltip="Currently not recording.\nNothing to stop",
            btn_tooltip="Stop recording",
        )
        self.stop_btn.grid(
            row=1, column=1, columnspan=2, padx=(20, 0), pady=(0, 10), sticky="se"
        )

        # Add recording feedback label
        self.recording_label = tcw.CTkLabel(self, text="Not recording")
        self.recording_label.grid(row=2, column=1, padx=(0, 10), sticky="se")

        # Add record button
        self.record_btn = tcw.CTkButton(
            self,
            text="Start recording",
            command=self.record_topics,
            tooltip_text=(
                "Start recording the\nselected topics",
                "Currently recording,\nstop before starting new",
            ),
        )
        self.record_btn.grid(row=2, column=2, sticky="se")

        self.update_is_recording()
        self.window = None

    def record_topics(self):
        """
        Starts recording the selected topics using tmux and ros2 bag
        """
        tmux_session = "BirdWatch"

        # Check if tmux session exists
        try:
            sh.execute(f"tmux has-session -t {tmux_session}")
        except:
            LogManager.error("Tmux session does not exist. Cannot start recording")
            if self.window is None or not self.window.winfo_exists():
                self.window = MessageWindow(
                    self,
                    f"No session named {tmux_session} found on\ntarget device. Cannot start recording",
                    "Error",
                )
            return

        # Get topics to record
        topics_to_record = ""
        for group in self.topics_frame.topics_config:
            # Check if group is to be recorded
            if self.topics_frame.topics_config[group]["record_group"]:
                for topic in self.topics_frame.topics_config[group]["topics"]:
                    # Check if topic is to be recorded
                    if topic["record_topic"]:
                        topics_to_record += topic["name"] + " "

        # Check if any topics are selected
        if topics_to_record != "":
            if self.window is None or not self.window.winfo_exists():
                self.window = NameRecordWindow(self, topics_to_record, tmux_session)
        else:
            LogManager.error("No topics selected for recording")
            if self.window is None or not self.window.winfo_exists():
                self.window = MessageWindow(
                    self, "No topics selected for recording", "Error"
                )

    def stop_recording(self):
        """
        Stops the recording of the selected topics
        """
        tmux_session = "BirdWatch"

        try:
            # Check if tmux session exists
            sh.execute(f"tmux has-session -t {tmux_session}")
        except:
            LogManager.error("Tmux session does not exist. Cannot stop recording")
            return

        # Check if the "rec" window already exists
        list_windows_output = sh.execute(f"tmux list-windows -t {tmux_session}")
        if "rec" not in list_windows_output:
            LogManager.error(
                '"rec" window does not exist in Tmux session. Cannot stop recording'
            )
            return

        try:
            # Send 'Ctrl+C' to the "rec" window
            sh.execute(f"tmux send-keys -t {tmux_session}:rec C-c")
            LogManager.info("Stopped recording")

        except Exception as e:
            LogManager.error(f"Error stopping recording: {e}")

    def view_recordings(self):
        """
        Opens a window to backup the recorded files on the directory specified in the target device configuration file
        """
        # Load the list of all files in the specified recordings folder
        try:
            if self.ros_version == '1':
                recordings_list = fm.list_files(
                    Settings.current_device.files.recordings.path
                )
            else:
                recordings_list = fm.list_directories(
                    Settings.current_device.files.recordings.path
                )
        except Exception as e:
            LogManager.error(f"Error loading recordings list: {e}")
            recordings_list = None

        # Check if the list is not empty
        if self.window is None or not self.window.winfo_exists():
            if not recordings_list or recordings_list == [""]:
                self.window = MessageWindow(
                    self,
                    f"No recordings found in '{Settings.current_device.files.recordings.path}'",
                    "Error",
                )
            else:
                self.window = backupRecordingsWindow(self, recordings_list)

    def update_is_recording(self):
        try:
            if self.ros_version == '1':
                search_string = 'rosbag record'
            else:
                search_string = 'ros2 bag record'
            # grep -v $$ to exclude own process to ensure command works as expected locally
            output = sh.execute(f"pgrep -f '{search_string}' | grep -v $$ || true")
            self.recording = len(output) > 0
        except:
            self.recording = None

        if self.recording is None:
            self.recording_label.configure(text="Error: no info on recording")
            self.stop_btn.slider_disable()
            self.record_btn.configure(state=tkinter.DISABLED)
            self.move_map_btn.configure(state=tkinter.DISABLED)
        elif self.recording:
            self.recording_label.configure(text="Recording...")
            self.stop_btn.slider_enable()
            self.record_btn.configure(state=tkinter.DISABLED)
            self.move_map_btn.configure(state=tkinter.DISABLED)
        else:
            self.recording_label.configure(text="Not recording")
            self.stop_btn.slider_disable()
            self.record_btn.configure(state=tkinter.NORMAL)
            self.move_map_btn.configure(state=tkinter.NORMAL)

        self.after(1000, self.update_is_recording)

    def move_map(self):
        """
        Moves the map to the location of the last recording
        """
        if not fm.exists("~/.ros/rtabmap.db"):
            LogManager.error("No map to move")
            self.window = MessageWindow(self, "No map to move in ~/.ros/", "Error")
            return

        if self.last_recording is None:
            new_map_name = f'{datetime.now().strftime("%Y-%m-%d-%H-%M-%S")}.db'
        else:
            new_map_name = f"{self.last_recording}.db"

        try:
            fm.copy_file(
                "~/.ros/rtabmap.db",
                f"{Settings.current_device.files.recordings.path}{new_map_name}",
                keep_original=False,
            )
        except:
            LogManager.error("Error moving map")
            self.window = MessageWindow(
                self,
                f"Error moving map to\n{Settings.current_device.files.recordings.path}",
                "Error",
            )

        self.last_recording = None

        LogManager.info(
            f"Moved map to {Settings.current_device.files.recordings.path}{new_map_name}"
        )
        self.window = MessageWindow(
            self,
            f"Moved map to\n{Settings.current_device.files.recordings.path}{new_map_name}",
            "Success",
        )


class TopicsFrame(tcw.CTkScrollableFrame):
    """
    A frame to display and manage the topics to be recorded.
    """

    def __init__(self, master):
        super().__init__(master)

        self.columnconfigure((0, 1), weight=1)

        # Add refresh button
        self.refresh_button = tcw.CTkButton(
            self, text="Refresh list", command=self.refresh
        )
        self.refresh_button.grid(
            row=0,
            column=0,
            padx=10,
            pady=(10, 0),
            sticky="nw",
        )

        # Add refresh button
        self.edit_button = tcw.CTkButton(
            self, text="Edit in File", command=self.open_file_to_edit
        )
        self.edit_button.grid(
            row=0,
            column=1,
            padx=10,
            pady=(10, 0),
            sticky="ne",
        )

        # Load topics from file
        self.load_and_add_topics()

    def load_file(self):
        """
        Loads the topics configuration from a YAML file.
        """
        try:
            topics_config: dict = yaml.safe_load(
                fm.read_file(Settings.current_device.files.topics.path)
            )
        except Exception as e:
            LogManager.error(f"Could not read topics configuration file: {e}")
            raise e

        self.topics_config = {}
        # For each group in the file
        for group in topics_config:
            self.topics_config[group] = {}
            if "record_group" in topics_config[group]:
                # Check if the group should be recorded
                self.topics_config[group]["record_group"] = topics_config[group][
                    "record_group"
                ]
            else:
                # Keep the old format for backwards compatibility
                self.topics_config[group]["record_group"] = True

            topics = []
            if "topics" in topics_config[group]:
                # For each topic in the group
                for topic in topics_config[group]["topics"]:
                    topic_entry = {}

                    # Check if the topic should be recorded
                    if "record_topic" in topic:
                        topic_entry["record_topic"] = topic["record_topic"]
                    else:
                        topic_entry["record_topic"] = True

                    # Resolve environment variables in topic name
                    topic_name = sh.execute(f'echo {topic["name"]}').strip()

                    # Get the name of the topic
                    topic_entry["name"] = topic_name

                    # Add the topic to the list of topics
                    topics.append(topic_entry)
            else:
                # Keep the old format for backwards compatibility
                for topic in topics_config[group]:
                    topic_entry = {}
                    topic_entry["record_topic"] = True
                    topic_entry["name"] = topic
                    topics.append(topic_entry)

            # Add the topics to the group
            self.topics_config[group]["topics"] = topics

    def open_file_to_edit(self):
        sh.open_terminal(command=f"nano {Settings.current_device.files.topics.path}")

    def load_and_add_topics(self):
        """
        Loads the topics from the file and adds them to the frame.
        """
        # Load file
        try:
            self.load_file()
        except:
            LogManager.error("Could not load topics file")
            self.no_file_label = tcw.CTkLabel(
                self, text="Topics could not be\nloaded with current settings."
            )
            self.no_file_label.grid(row=1, column=0, columnspan=2, pady=10)
            return

        # Add topics
        self.group_entries: List[GroupFrame] = []

        for row, (group_name, values) in enumerate(self.topics_config.items(), start=1):
            group_entry = GroupFrame(
                self, group_name, values["record_group"], values["topics"]
            )
            group_entry.grid(
                row=row,
                column=0,
                columnspan=2,
                padx=10,
                pady=10 if row == 1 else (0, 10),
                sticky="new",
            )
            self.group_entries.append(group_entry)

        # Set the height of the frame so it is not larger than it needs to be
        self.configure(height=self.get_slaves_total_height())

    def refresh(self):
        """
        Refreshes the topics list by reloading the topics file.
        """
        for group in self.group_entries:
            group.destroy()
        self.load_and_add_topics()

    def save_file(self):
        """
        Saves the topics configuration to a YAML file.
        """
        try:
            fm.write_file(
                Settings.current_device.files.topics.path,
                yaml.dump(self.topics_config, sort_keys=False),
            )
        except Exception as e:
            LogManager.error(f"Could not save topics configuration file: {e}")


class GroupFrame(tcw.CTkFrame):
    """
    A frame representing a single group and its topics.
    """

    def __init__(self, master: TopicsFrame, group: str, record: bool, topics: List):
        """
        Initializes the GroupFrame

        Args:
            master: The parent TopicsFrame
            group: The name of the group
            record: Whether the group should be recorded
            topics: A list of topics related to the group
        """
        super().__init__(master, fg_color="gray20")

        self.master = master
        self.group = group

        # Add checkbox
        self.record_checkbox = tcw.CTkCheckBox(
            self,
            text=group,
            font=ctk.CTkFont(weight="bold"),
            width=0,
            command=self.update_record_group,
            tooltip_text="Selected: the selected topics in this category will be recorded\n"
            + "Unselected: no topic in this category will not be recorded",
        )
        self.record_checkbox._check_state = record
        self.record_checkbox._draw()
        self.record_checkbox.grid(row=0, column=0, padx=(5, 0), pady=5, sticky="nw")

        self.topics: List[tcw.CTkCheckBox] = []
        for row, topic in enumerate(topics, start=1):
            topic_entry = tcw.CTkCheckBox(
                self,
                text=topic["name"],
                width=0,
                command=lambda topic_index=(row - 1): self.update_record_topic(
                    topic_index
                ),
                tooltip_text=(
                    "Selected: this topic will be recorded\n"
                    + "Unselected: this topic will not be recorded",
                    "This topic will not be recorded\n"
                    + "since the category is not selected",
                ),
            )
            topic_entry._check_state = topic["record_topic"]
            if not record:
                topic_entry.configure(state=tkinter.DISABLED)
                topic_entry.configure(fg_color="gray60")
            topic_entry._draw()
            topic_entry.grid(row=row, column=0, padx=(20, 5), pady=(0, 5), sticky="nw")

            self.topics.append(topic_entry)

    def update_record_group(self):
        """
        Updates weather the group should be recorded or not, and enables/disables the topics accordingly.
        """
        self.master.topics_config[self.group][
            "record_group"
        ] = self.record_checkbox._check_state

        self.master.save_file()

        for topic in self.topics:
            if self.record_checkbox._check_state:
                topic.configure(state=tkinter.NORMAL)
                topic.configure(fg_color=Settings.current_device.color_theme.primary)
            else:
                topic.configure(state=tkinter.DISABLED)
                topic.configure(fg_color="gray60")
            topic._draw()

    def update_record_topic(self, topic_index):
        """
        Updates weather the topic should be recorded or not

        Args:
            topic_index: The index of the topic to update.
        """
        self.master.topics_config[self.group]["topics"][topic_index]["record_topic"] = (
            self.topics[topic_index]._check_state
        )

        self.master.save_file()


class backupRecordingsWindow(tcw.CTkToplevel):
    """
    A window for backing up recordings with options to delete after backup.
    """

    def __init__(self, master, file_list: List[str]):
        """
        Initializes the backupRecordingsWindow.

        Args:
            master: The parent widget.
            file_list: A list of files to be backed up.
        """
        super().__init__(master)

        self.title("Back up Recordings")
        self.columnconfigure((0, 1), weight=1)
        self.rowconfigure(0, weight=1)

        # Frame to display the list of files
        self.file_list = tcw.CTkScrollableFrame(self)
        self.file_list.grid(
            row=0, column=0, columnspan=2, padx=10, pady=10, sticky="new"
        )

        self.bagfiles: List[tcw.CTkCheckBox] = []
        self.bagfiles_selected: List[tkinter.BooleanVar] = []
        self.ros_version = sh.execute('echo $ROS_VERSION')

        # Add a label for each file in the file list
        for index, file in enumerate(file_list, start=0):
            self.bagfiles_selected.append(tkinter.BooleanVar())

            if self.ros_version == '1':
                file_size = fm.get_file_size(
                    f"{Settings.current_device.files.recordings.path}/{file}",
                    human_readable=True,
                )
            else:
                file_size = fm.get_directory_content_size(
                    f"{Settings.current_device.files.recordings.path}/{file}",
                    human_readable=True,
                )

            self.bagfiles.append(
                tcw.CTkCheckBox(
                    self.file_list,
                    text=f"{file} ({file_size})",
                    variable=self.bagfiles_selected[-1],
                    command=lambda: self.update_btn(),
                )
            )
            self.bagfiles[-1].grid(row=index, column=0, padx=10, pady=5, sticky="nw")

        self.file_list.configure(height=self.file_list.get_slaves_total_height())

        # Switch to select between remote and local destination
        if Settings.is_ssh_config_set():
            self.destiny_device_frame = tcw.CTkFrame(self, fg_color="transparent")
            self.destiny_device_frame.grid(
                row=1, column=0, columnspan=2, padx=10, pady=(0, 10), sticky="nw"
            )

            self.destiny_device_src_label = tcw.CTkLabel(
                self.destiny_device_frame,
                text="From the remote device to:",
                tooltip_text="Switch between remote and local destination",
            )
            self.destiny_device_src_label.grid(
                row=0, rowspan=2, column=0, padx=(0, 15), sticky="w"
            )

            self.destiny_device_var = tkinter.IntVar(
                value=-1
            )  # -1: no option selected, 0: remote, 1: local

            self.destiny_device_remote = tcw.CTkRadioButton(
                self.destiny_device_frame,
                text="remote",
                variable=self.destiny_device_var,
                value=0,
                tooltip_text="Copy the recordings stored in the remote device\n"
                + "to the specified location in the remote device",
            )
            self.destiny_device_remote.grid(row=0, column=1, pady=(0, 2.5), sticky="w")

            self.destiny_device_local = tcw.CTkRadioButton(
                self.destiny_device_frame,
                text="local",
                variable=self.destiny_device_var,
                value=1,
                tooltip_text="Copy the recordings stored in the remote device\n"
                + "to the specified location in the local device (this computer)",
            )
            self.destiny_device_local.grid(row=1, column=1, pady=(2.5, 0), sticky="w")

        # Entry for the destination directory
        self.destiny_entry_frame = tcw.CTkFrame(self, fg_color="transparent")
        self.destiny_entry_frame.columnconfigure(0, weight=1)
        self.destiny_entry_frame.grid(
            row=2, column=0, columnspan=2, padx=10, pady=(0, 10), sticky="new"
        )

        self.destiny_entry = EntryWithLabel(
            self.destiny_entry_frame,
            "Destiny:",
            placeholder_text="/media/user/DRIVE/",
            tooltip=(
                "Destination directory in the remote device"
                if not Settings.is_ssh_config_set()
                else (
                    "Destination directory in the remote device",
                    "Select target device first",
                )
            ),
        )
        self.destiny_entry.grid(row=0, column=0, padx=(0, 10), sticky="ew")
        self.destiny_entry.textvar.trace_add("write", self.update_btn)

        self.destiny_path_button = tcw.CTkButton(
            self.destiny_entry_frame,
            text="",
            image=IconManager.folder.icon,
            width=0,
            command=lambda: self.browse_directory(),
            tooltip_text=(
                "Select the destination directory"
                if not Settings.is_ssh_config_set()
                else ("Select the destination directory", "Select target device first")
            ),
        )
        self.destiny_path_button.grid(row=0, column=1, sticky="e")

        if Settings.is_ssh_config_set():
            self.set_destiny_entry_state("disabled")
            self.destiny_device_var.trace_add(
                "write", lambda *args: self.set_destiny_entry_state("normal")
            )
        # Checkbox to delete the recordings after backing them up
        self.delete_checkbox_var = tkinter.BooleanVar(value=False)
        self.delete_checkbox = tcw.CTkCheckBox(
            self,
            text="Delete after backup",
            variable=self.delete_checkbox_var,
            onvalue=True,
            offvalue=False,
            tooltip_text="Delete the recordings after backing them up",
        )
        self.delete_checkbox.grid(
            row=3, column=0, columnspan=2, padx=10, pady=(0, 10), sticky="nw"
        )

        # Button to start the backup process
        self.delete_button = tcw.CTkButton(
            self,
            text="Delete",
            command=self.open_confirm_to_delete,
            tooltip_text=(
                "Delete the selected recordings",
                "No recording selected to delete",
            ),
        )
        self.delete_button.grid(row=4, column=0, padx=10, pady=(0, 10), sticky="nw")

        # Button to start the backup process
        self.backup_button = tcw.CTkButton(
            self,
            text="Back up",
            command=self.backup,
            tooltip_text=(
                "Copy the recordings to the specified location",
                "Specify the destination directory before backing up",
            ),
        )
        self.update_btn()
        self.backup_button.grid(row=4, column=1, padx=10, pady=(0, 10), sticky="ne")

        self.window = None

    def browse_directory(self):
        """
        Opens a file dialog to select the destination directory.
        """
        if self.window is None or not self.window.winfo_exists():
            self.window = FileDialog(
                self,
                select_command=lambda path: self.destiny_entry.textvar.set(path),
                title="Select destination directory",
                initial_dir=self.destiny_entry.textvar.get(),
                force_local=not Settings.is_ssh_config_set()
                or self.destiny_device_var.get() == 1,
            )

    def set_destiny_entry_state(self, state: str, *args):
        if state == "disabled":
            self.destiny_entry.label.configure(
                text_color=ctk.ThemeManager.theme["CTkButton"]["text_color_disabled"]
            )
            self.destiny_entry.entry.configure(state="disabled")
            self.destiny_entry.entry.configure(
                text_color=ctk.ThemeManager.theme["CTkEntry"]["placeholder_text_color"]
            )
            self.destiny_path_button.configure(state="disabled")
            self.destiny_path_button.configure(image=IconManager.folder.icon_gray)
        elif state == "normal":
            self.destiny_entry.label.configure(
                text_color=ctk.ThemeManager.theme["CTkLabel"]["text_color"]
            )
            self.destiny_entry.entry.configure(state="normal")
            self.destiny_entry.entry.configure(
                text_color=ctk.ThemeManager.theme["CTkEntry"]["text_color"]
            )
            self.destiny_path_button.configure(state="normal")
            self.destiny_path_button.configure(image=IconManager.folder.icon)

            self.update_btn()

    def update_btn(self, *args):
        """
        Updates the state of the backup button based on the state of the entry.
        """
        any_selected = any([var.get() for var in self.bagfiles_selected])

        if (
            any_selected
            and (not Settings.is_ssh_config_set() or self.destiny_device_var.get() > -1)
            and self.destiny_entry.textvar.get() != ""
        ):
            self.delete_button.configure(state="normal")
            self.backup_button.configure(state="normal")
        else:
            self.delete_button.configure(state="disabled")
            self.backup_button.configure(state="disabled")

    def backup(self):
        """
        Backs up the selected recordings to the specified destination.
        """
        if not any([var.get() for var in self.bagfiles_selected]):
            LogManager.error("No recordings selected to back up")
            return

        # Check if it is connected to the remote device and the destination is set to the local device
        download_to_local = (
            Settings.is_ssh_config_set() and self.destiny_device_var.get() == 1
        )

        # Create the destination directory if it does not exist
        try:
            fm.mkdir(
                self.destiny_entry.textvar.get(),
                force_local=download_to_local,
            )
        except Exception as e:
            LogManager.error(f"Error creating directory: {e}")
            return

        # Generate the rsync command
        command = "rsync -avPh "
        if self.delete_checkbox.get():
            command += "--remove-source-files "

        # Add the selected files
        for file in self.bagfiles:
            if file.get():
                file_name = file.cget("text").rsplit(" (", 1)[0]
                if download_to_local:
                    command += f"{Settings.current_device.ssh_config.username}@{Settings.current_network.ip}:"
                command += (
                    f"{Settings.current_device.files.recordings.path}/{file_name} "
                )

        # Add the destination directory
        command += self.destiny_entry.textvar.get()

        try:
            sh.open_terminal(command, force_local=download_to_local)
            LogManager.info(
                f"Backing up recordings to {self.destiny_entry.textvar.get()} in the {'local' if not Settings.is_ssh_config_set() or download_to_local else 'remote'} device"
            )
        except Exception as e:
            LogManager.error(f"Error backing up recordings: {e}")

        # Close the window
        self.destroy()

    def open_confirm_to_delete(self):
        """
        Opens a confirmation window to delete the selected recordings.
        """
        if not any([var.get() for var in self.bagfiles_selected]):
            LogManager.error("No recordings selected to delete")
            return

        if (self.window is None) or (not self.window.winfo_exists()):
            self.window = ConfirmationWindow(
                self,
                title="Delete Recordings",
                message="Are you sure you want to delete the selected recordings?",
                confirm_command=self.delete,
            )

    def delete(self):
        """
        Deletes the selected recordings.
        """
        for file in self.bagfiles:
            if file.get():
                try:
                    file_name = file.cget("text").rsplit(" (", 1)[0]
                    fm.delete_file(
                        f"{Settings.current_device.files.recordings.path}/{file_name}"
                    )
                    LogManager.info(f"Deleted recording {file_name}")
                except Exception as e:
                    LogManager.error(f"Error deleting recording {file_name}: {e}")

        # Close the window
        self.destroy()


class NameRecordWindow(tcw.CTkToplevel):
    def __init__(
        self, master: RecordTopicsTabView, topics: List[str], tmux_session: str
    ):
        super().__init__(master)

        self.title("Name file")
        self.columnconfigure(0, weight=1)
        self.rowconfigure((0, 1), weight=1)

        self.master: RecordTopicsTabView = master
        self.topics = topics
        self.tmux_session = tmux_session
        self.ros_version = sh.execute('echo $ROS_VERSION')

        self.file_name = tkinter.StringVar(
            value=datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
        )
        self.name_entry = tcw.CTkEntry(self, textvariable=self.file_name, width=300)
        self.name_entry.grid(row=0, column=0, padx=(10, 5), pady=10, sticky="new")
        self.file_name.trace_add("write", self.update_btn)

        self.save_button = tcw.CTkButton(
            self,
            text="Start recording",
            command=self.record,
            tooltip_text=("", "Enter a name for the file"),
        )
        self.save_button.grid(
            row=1, column=0, columnspan=2, padx=10, pady=10, sticky="ne"
        )

        self.bind("<Return>", lambda event: self.save_button.invoke())
        self.bind("<KP_Enter>", lambda event: self.save_button.invoke())

    def update_btn(self, *args):
        """
        Updates the state of the backup button based on the state of the entry.
        """
        if self.file_name.get() != "":
            self.save_button.configure(state="normal")
        else:
            self.save_button.configure(state="disabled")

    def record(self):
        # Generate command to record topics
        file_name = (
            f"{Settings.current_device.files.recordings.path}{self.file_name.get()}"
        )
        if self.ros_version == '1':
            command = f"rosbag record {self.topics} -O {file_name}.bag"
        else:
            command = f"ros2 bag record {self.topics} -o {file_name} -s mcap --max-cache-size 1000000000 --storage-preset-profile zstd_fast"

        # Check if the "rec" window already exists
        window_exists = False
        list_windows_output = sh.execute(f"tmux list-windows -t {self.tmux_session}")
        if "rec" in list_windows_output:
            window_exists = True

        # If the window does not exist, create it
        if not window_exists:
            sh.execute(f'tmux new-window -t "{self.tmux_session}" -n "rec"')

        # Send the command to the "rec" window
        sh.execute(f'tmux send-keys -t "BirdWatch:rec" "{command}" C-m')

        LogManager.info(f"Started recording topics to file {file_name}")
        LogManager.info(f"  Topics: {self.topics}")

        self.master.last_recording = self.file_name.get()

        self.destroy()
